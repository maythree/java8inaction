## Chapter5 스트림 활용

  
> 외부 반복을 내부 반복으로 바꿔 편리하게 데이터 관련 작업을 처리한다.  
> 스트림 API 내부적으로 다양한 최적화가 이루어질 수 있다.

### 이 장의 내용
- 필터링, 슬라이싱, 매칭
- 검색, 매칭, 리듀싱
- 특정 범위의 숫자와 같은 스트림 사용하기
- 다중 소스로부터 스트림 만들기
- 무한 스트림

  
### 5.1 필터링과 슬라이싱 

- 프리디케이트로 필터링  
  
  : **filter** 메서드는 프리디케이트(불린을 반환하는 함수)를 인수로 받아서
 프리디케이트와일치하는 모든 요소를 포함하는 스트림을 반환한다.
    ~~~java
    List<Dish> vegetarianMenu = menu.stream()
                                    .filter(Dish::isVegetarian)
                                    .collect(toList());
    
    ~~~

- 고유 요소 필터링  
  
  : **distinct** 메서드는 고유 요소로 이루어진(중복을 제거한) 스트림을 반환한다.  
고유 여부는 hashCode, equals로 결정된다.
    ~~~java
    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
    numbers.stream()
           .filter(i -> i % 2 == 0)
           .distinct()
           .forEach(System.out::println);
    ~~~

- 스트림 축소  
  
  : **limit(n)** 메서드는 주어진 사이즈 이하의 크기를 갖는 새로운 스트림을 반환한다.  
  &nbsp;&nbsp;정렬되어 있으면 정렬된 n개의 요소를, 그렇지 않은 스트림은 정렬되지 않은 n개의 요소를 반환한다.
    ~~~java
    List<Dish> dishs = menu.stream()
                           .filter(d -> d.getCalories() > 300)
                           .limit(3)
                           .collect(toList);
    ~~~
      
- 요소 건너뛰기  
  
  : **skip(n)** 메서드는 처음 n개 요소를 제왜ㅣ한 스트림을 반환한다.  
  &nbsp;&nbsp;n개 이하의 요소를 포함하는 스트림에 호출하면 빈 스트림이 반환된다.
    ~~~java
    List<Dish> dishs = menu.stream()
                           .filter(d -> d.getCalories() > 300)
                           .skip(2)
                           .collect(toList);
    ~~~

### 5.2 매핑

- 스트림의 각 요소에 함수 적용하기 
  
    : **map** 메서드는 함수를 인수로 받아 각 요소에 함수를 적용한 결과를 새로운 요소로 매핑(변환)하여 반환한다. 
     ~~~java
     List<String> dishsName = menu.stream()
                                  .map(Dish::getName)
                                  .map(String::length)
                                  .collect(toList);
     ~~~

- 스트림 평면화
  
    : **flatMap** 메서드는 스트림의 각 값을 다른 스트림(스트림의 콘텐츠)으로 만든 다음 하나의 평면화된 스트림으로 연결하여 반환한다. 
     ~~~java
     List<String> uniqueCharacters = word.stream()
                                         .map(w -> w.split(""))
                                         .flatMap(Arrays::stream)
                                         .distinct()
                                         .collect(Collectors.toList);
     ~~~

### 5.3 검색과 매칭


>쇼트서킷 평가  
  
    전체 스트림을 처리하지 않았더라도 결과를 반환한다.  
    하나라도 결과가 나오면 나머지 표현식의 결과가 상관없는 상황을 **쇼트서킷**이라 부른다.  
    allMatch, noneMatch, findFirst, findAny 등의 연산이 해당된다.  
    무한한 요소를 가진 스트림을 유한한 크기로 줄일 때 유용하다.

- 프레디케이트가 적어도 한 요소와 일치하는지 확인
  
    : **anyMatch** 메서드는 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인하여 boolean을 반환한다.
     ~~~java
     if(menu.stream().anyMatch(Dish::isVegetarian)) {  
         System.out.println("The menu is (somewhat) vegetarian friendly!!");
     }
     ~~~

- 프레디케이트가 모든 요소와 일치하는지 검사()
  
    : **allMatch** 메서드는 스트림의 모든 요소가 프레디케이트와 일치하는지 검사한다.
     ~~~java
     boolean isHealthy = menu.stream()
                             .allMatch(d -> d.getCalories() < 1000);
     ~~~
  
    : **noneMatch** 메서드는 주어진 프레디케이트와 일치하는 요소가 없는지 확인한다.
     ~~~java
     boolean isHealthy = menu.stream()
                             .noneMatch(d -> d.getCalories() >= 1000);
     ~~~

- 요소 검색
  
    : **findAny** 메서드는 현재 스트림에서 임의의 요소를 반환한다.
     ~~~java
     Optional<Dish> dish = menu.stream()
                               .filter(Dish::isVegetarian)
                               .findAny();
     ~~~
     
- 첫 번째 요소 찾기
  
    : **findFirst** 메서드는 첫 번째 요소를 반환한다.  
    &nbsp;&nbsp;리스트 또는 정렬된 연속 데이터와 같은 논리적인 아이템 순서가 정해져 있는 경우 사용한다.  
    &nbsp;&nbsp;병렬 실행의 경우 첫 번째 요소를 찾기 어렵기 때문에 findFirst, 아닌 경우 제약이 적은 findAny를 사용한다.
     ~~~java
     List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
     Optional<Integer> firstSquareDivisibleByThree =
          someNumbers.stream()
                     .map(x -> x * x)
                     .filter(x -> x % 3 == 0)
                     .findFirst();
     ~~~


>Optional이란? 
  
    Optional<T> 클래스(java.util.Optional)는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스다.  
    findAny의 경우 아무 요소도 반환하지 않을 수 있으므로 null 에러를 발생할 수 있다.  
    (null확인 관련 버그를 피하는 방법은 10장에서 설명한다.)  
    Optional은 값이 존재하는지 확인하고 없을 때 어떻게 처리할 것인지 강제하는 기능을 제공한다.
      
    - isPresent(): Optional이 값을 포함하면 true, 포함하지 않으면 false를 반환한다.  
    - isPresent(Consumer<T> block): 값이 있으면 주어진 블록을 실행한다.  
    - T get(): 값이 존재하면 값을 반환하고, 없으면 NoSuchElementException을 일으킨다.  
    - T orElse(T other): 값이 있으면 값을 반환하고, 없으면 기본값을 반환한다.

~~~java
Optional<Dish> dish = menu.stream()
                          .filter(Dish::isVegetarian)
                          .findAny()
                          .ifPresent(d -> System.out.println(d.getName());
~~~